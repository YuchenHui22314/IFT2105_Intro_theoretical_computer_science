\documentclass{article}

%=============================================
%===       importation des packages.        ==
%=============================================
\usepackage{tabularx, makecell, multirow }
\usepackage{syntonly}
%hpyerlien
\usepackage{hyperref}
%utf8
\usepackage[utf8]{inputenc}
%to solve footnote too high 
%(this helps fix footnote to bottom of the page)
\usepackage[bottom]{footmisc}
%array: aimed at tabular
\usepackage{array}
% sanxianbiao
\usepackage{booktabs}
% graphics
\usepackage{graphicx}
%math
\usepackage{amsmath}
\usepackage{amsthm}
%Algo
\usepackage{algorithm}
\usepackage{algorithmic}
%code
\usepackage{listings}
\usepackage{xcolor}
\usepackage[]{amssymb}

%=============================================
%===            Code config                 ==
%=============================================

%New colors defined below
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

%Code listing style named "mystyle"
\lstdefinestyle{mystyle}{
  backgroundcolor=\color{backcolour}, commentstyle=\color{codegreen},
  keywordstyle=\color{magenta},
  numberstyle=\tiny\color{codegray},
  stringstyle=\color{codepurple},
  basicstyle=\ttfamily\footnotesize,
  breakatwhitespace=false,         
  breaklines=true,                 
  captionpos=b,                    
  keepspaces=true,                 
  numbers=left,                    
  numbersep=5pt,                  
  showspaces=false,                
  showstringspaces=false,
  showtabs=false,                  
  tabsize=2
}

%"mystyle" code listing set
%++++++++++++++++ end config code +++++++++++
\lstset{style=mystyle}

%=============================================
%===       Définition des environnements.   ==
%=============================================
\newtheorem{theoreme}{Théorème}
\newtheorem*{theoreme*}{Théorème}
\newtheorem{proposition}{Proposition}
\newtheorem*{proposition*}{Proposition}
\newtheorem{lemme}{Lemme}[section]
\newtheorem*{lemme*}{Lemme}
\newtheorem{corollaire}{Corollaire}
\newtheorem*{corollaire*}{Corollaire}
\newtheorem{conjecture}{Conjecture}
\newtheorem*{conjecture*}{Conjecture}

\theoremstyle{definition}
\newtheorem{definition}{Définition}
\newtheorem*{definition*}{Définition}
\newtheorem{notation}{Notation}
\newtheorem*{notation*}{Notation}
\newtheorem{exercice}{Exercice}
\newtheorem*{exercice*}{Exercice}
\newtheorem{probleme}{Problème}
\newtheorem*{probleme*}{Problème}
\newtheorem{question}{Question}
\newtheorem*{question*}{Question}
\newtheorem*{solution}{Solution}
\newtheorem*{code}{Code}

\theoremstyle{remark}
\newtheorem{exemple}{Exemple}[section]
\newtheorem*{exemple*}{Exemple}
\newtheorem{remarque}{Remarque}[section]
\newtheorem*{remarque*}{Remarque}
\newtheorem*{enigme}{Énigme}

%=============================================
%==        Définition des new commands.     ==
%=============================================
% Notation -- délimiteurs :
\newcommand{\ac}[1]{\left\{ #1 \right\}} 
% accolades
\newcommand{\pr}[1]{\left( #1 \right)} 
% parenthèses
\newcommand{\ct}[1]{\left[ #1 \right]} 
% crochets
\newcommand{\norm}[1]{\left\Vert #1 \right\Vert} 
% norme
\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor} 
% partie entière
\newcommand{\ceil}[1]{\left\lceil #1 \right\rceil} 
% partie entière + 1
\newcommand{\cond}{\ \middle\vert \ }

\title{\textbf{IFT2105 Devoir3}}
\author{
    Samy Rasmy 20214818 \and Yuchen Hui 20150470}
\date{\today}

\begin{document}

\maketitle

\section*{Question1}
\section*{Question2 a) 3-ClIQUE}
3-CLIQUE est un langage dans la classe P.
\begin{proof}
	On donne un algorithme en temps polynômial.\\
	    \begin{algorithm} 
		\caption{\textbf{fonction 3-CLIQUE?} $(G\left[ 1\ldots n,1\ldots n \right] )$: bool}
		\label{3-clique} 
		\begin{algorithmic}
		\STATE \COMMENT{ici on représnete le graphe par une matrice adjacente de $n*n$, où $n$ est le nombre de noeud. S'il exsite une arête entre noeud i et noeud j, alors $Gi\left[ i,j \right] = true$ ; sinon $G\left[ i,j \right] = false$.} 
		\STATE \textbf{for} $i = 1$ \textbf{ to } $n$ \textbf{ do}	
		\STATE \qquad\textbf{for} $j = 1$ \textbf{ to } $n$ \textbf{ do}	
		\STATE \qquad\qquad \textbf{if} $G\left[ i,j \right] == true $ \textbf{then}
		\STATE \qquad\qquad\qquad \textbf{for} $k = 1$ \textbf{ to } $n$ \textbf{ do}
		\STATE \qquad\qquad\qquad\qquad \textbf{if} $G\left[ i,k \right]  == true \text{ AND } G\left[ k,j \right] == true $ \textbf{then}
		\STATE \qquad\qquad\qquad\qquad\qquad \textbf{return} true 

		\STATE \textbf{return} false
		\end{algorithmic} 
	    \end{algorithm}\\
	    On voit bien que la complexité en temps est de $\mathcal{O} \left ( n^{3} \right ) \text{(n est le nombre des noeuds)}$, d'où le langage 3-CLIQUE $\in P$
 
\end{proof}
\section*{Question2 b) 3-DOUBLE-SAT}
Le langage 3-DOUBLE-SAT est NP-Complet.
\begin{proof}
	On prouve d'abord qu'il $\in NP$ 
	\subsection {3-DOUBLE-SAT $\in NP$}
	Un certificat est deux affectation des varibles pour l'expression booléenne. Un vérificateur accepte si tous les deux affectations rendent l'expression vraie, sinon il rejette. Évidement, ce vérificateur travaille dans $\mathcal{O} \left ( n \right ) $, où n est le nombre de clauses dans l'expression booléenne.
	\subsection {3-SAT $\le_{p}$ 3-DOUBLE-SAT }
	Soit la fonction de réduction:
	\begin{align*}
		f: \Sigma^{*} &\longrightarrow \Sigma^{*} \\
		 \text{<}E\text{>}&\longmapsto f(\text{<}E\text{>})  
	.\end{align*}
	telle que \\
	si e est l'expression correspondant au <E>, alors $e\wedge\left( x_{i}\vee \overline{x_{i}} \vee \overline{x_{i}} \right) $ est l'expression représenté par $f\left( \text{<}E\text{>} \right),$ où on introduit une nouvelle variable $x_i$ qui avec $\overline{x_{i}} $ n'apparaissent jamais dans $e$.  	
	\subsubsection{<E> $\in \text{3-SAT} \implies f\left( \text{<E>} \right) \in \text{3-DOUBLE-SAT}$}
	soit $e$ est l'expression correspondant au <E>.
	\begin{align*}
		<E> \in \text{3-SAT} &\implies \text{il existe au moin une affectation (dénotons par A) qui satisfait }e\\
	&\implies \text{il existe au moin deux affectation (A}\cup [x_{i} =true] \text{) et (A} \cup [x_{i} = false]\text{)} \\ 
	&\qquad\qquad\text{qui satisfont } e \wedge \left( x_{i}\vee \overline{x_{i}} \vee \overline{x_{i}} \right)\\ 
	&\implies f\left( \text{<E>} \right) \in \text{3-DOUBLE-SAT}
	.\end{align*}
	\subsubsection{<E> $\notin \text{3-SAT} \implies f\left( \text{<E>} \right) \notin \text{3-DOUBLE-SAT}$}
	soit $e$ est l'expression correspondant au <E>.
	\begin{align*}
		<E> \notin \text{3-SAT} &\implies \text{il n'existe pas d'affectation qui satisfait }e \\
	&\implies \text{il n'existe pas d'affectation qui satisfait }e \wedge \left( x_{i}\vee \overline{x_{i}} \vee \overline{x_{i}} \right) \\ 
	&\qquad\text{, car $e$ prend toujour la valeur fause} \\ 
	&\implies f\left( \text{<E>} \right) \notin \text{3-DOUBLE-SAT}
	.\end{align*}
	\subsubsection{ Ça se voit que f est de $\mathcal{O} \left ( 1 \right ) \subseteq \mathcal{O} \left ( n \right ) $}

	Finalement, on peut conclure que 3-DOUBLE-SAT est NP-Complet, étant donné qu'il est à la fois $\in $ NP et NP-Difficile (un langage NP-Complet se réduit à lui).
\end{proof}

\section*{Question2 c) 4-COL}
Le langage 4-COL est NP-Complet.
\begin{proof}
	On prouve d'abord qu'il $\in \text{NP.}$ 
	\subsection {4-COL $\in NP$}
	Un certificat est un coloriage contenant 3 couleurs. Un vérificateur scanne toutes les arêtes et vérifie si les deux noeud adjacents de chaque arêtes portent des couleurs différentes. Si oui il l'acceptera, sinon il le rejette. Ce vérificateur travaille dans $\mathcal{O} \left ( |E| \right ) \subseteq \mathcal{O} \left ( |V|^{2} \right ) $, donc $\text{4-COL} \in $ NP.
	\subsection {3-COL $\le_{p}$ 4-COL }
	Soit la fonction de réduction:
	\begin{align*}
		f: \Sigma^{*} &\longrightarrow \Sigma^{*} \\
		 \text{<}G\text{>}&\longmapsto f(\text{<}G\text{>})  
	.\end{align*}
	telle que \\
	Dénotons $g$ le graphe correspondant au <G>, $g'$ le graphe correspondant au $f(\text{<}G\text{>}$. Nous construisons $g'$ en ajoutant un noeud supplémentaire au g et en reliant ce noeud aux tous les sommets de $g$. 
	\subsubsection{<G> $\in \text{3-COL} \implies f\left( \text{<G>} \right) \in \text{4-COL}$}
	Soit $g$ est le graphe correspondant au <G>. Soit $g'$ est le graphe correspondant au $f<G>$.
	\begin{align*}
		<G> \in \text{3-COL} &\implies \text{Graphe g est 3-coloriable }\\
	&\implies \text{Dans $g'$, si on assigne toujours au sommet ajouté une couleur} \\
	&\qquad \text{autres que les couleurs utilisé par les sommets de } g,\\
	&\qquad \text{il est possible d'obtenir un coloriage qui} \\
	&\qquad \text{n'utilise que 4 couleurs: Par exemple,} \\
	&\qquad \text{On colorie le sougraphe $g$ de $g'$ en utilisant} \\
	&\qquad \text{rouge, vert et bleu en formant un coloriage valide de g, } \\
	&\qquad \text{ensuite on colorie le sommnet supplémentaire en orange.} \\
	&\qquad\text{Ainsi on obtient un 4-coloriage valide de $g'$.}\\ 
	&\implies f\left( \text{<G>} \right) \in \text{4-COL}
	.\end{align*}
	\subsubsection{<G> $\notin \text{3-COL} \implies f\left( \text{<G>} \right) \notin \text{4-COL}$}
	Soit $g$ est le graphe correspondant au <G>. Soit $g'$ est le graphe correspondant au $f(<G>)$. <G> $\not\in$ 3-COL signifie qu'il faut au mois utiliser 4 couleurs afin que le graph $g$ soit coloriable. Ainsi, dans graphe $g'$, puisque le sommet qu'on ajoute est relié aux tous les sommets de $g$, il nous faut lui assigner une couleur autres que les couleurs utilisées par ces sommets pour que le praphe $g'$ soit coloriable. Alors il faut maintenant au moins 5 couleurs (4 aux $g$ et 1 au sommet ajouté) si on voudrait colorier  $g'$ correctement. Donc $g'$ n'est pas 4-coloriable et on peut conclure que $ f\left( \text{<}G\text{>} \right) \not\in \text{4-COL}.$
	\subsubsection{ Ça se voit que f est de $\mathcal{O} \left ( |V| \right )  $}

	Finalement, on peut conclure que 4-COL est NP-Complet, étant donné qu'il est à la fois $\in $ NP et NP-Difficile (un langage NP-Complet 3-COL se réduit à lui).
\end{proof}

\section*{Question3}
Soit $e$ l'expression booléenne sous considération, $x_1,x_2,\ldots, x_{n}$ les n variables qui apparaissent dans e (sous forme de $x_{i}$ ou $\overline{x_{i}}$). Maintenant étudions deux expression: $e_1 = e\wedge \left( x_{i} \vee x_{i} \vee x_{i} \right)  \text{et} e_2 = e \wedge \left( \overline{x_{i}} \vee\overline{x_{i}} \vee\overline{x_{i}}  \right)$. Supposons que Oracel($e$) accepte, i.e. e est satisfaisable(typo?). Alors on a:
\begin{align*}
	Oracle(e_1) == true &\implies \text{il existe une affectation satisfaisable où $x_{i}$ prend la valeur true.} \\  
	Oracle(e_2) == true &\implies \text{il existe une affectation satisfaisable où $x_{i}$ prend la valeur false.}   
.\end{align*}
Avec ces deux observations, on peut trouver un algorithme:\\
    \begin{algorithm} 
	\caption{\textbf{fonction} Affectation$(e):$ \textbf{array} $X[1\ldots n]$}
	\label{affectation_algo} 
	\begin{algorithmic}
		\STATE \COMMENT{e est l'expression booléenne, X est un tableau qui va contenir une affectation satisfaisable à la fin.}
		\STATE \textbf{if} Oracle(e) == false \textbf{then}
		\STATE \textbf{return} $e$ n'est pas satisfaisable.
		\STATE \textbf{for} $i = 1$ \textbf{to} $n$ \textbf{do}
		\STATE \qquad \textbf{if} Oracle($e\wedge \left( x_{i} \vee x_{i} \vee x_{i} \right)$) == true \textbf{then} 
		\STATE \qquad\qquad $e\gets e\wedge \left( x_{i} \vee x_{i} \vee x_{i} \right)$
		\STATE \qquad\qquad $X\left [ i \right ] == true $
		\STATE \qquad \textbf{else if} Oracle($e\wedge (\overline{x_{i}} \vee \overline{x_{i}} \vee \overline{x_{i}} )$) == true \textbf{then} 
		\STATE \qquad\qquad $e\gets e\wedge \left(\overline{x_{i}} \vee \overline{x_{i}} \vee \overline{x_{i}} \right)$
		\STATE \qquad\qquad $X\left [ i \right ] = false $
		\STATE \textbf{return} X
	
	\end{algorithmic} 
    \end{algorithm}
    Puisqu'un appel au Oracle prend un temps constant, cet algorithme s'execute en $\mathcal{O} \left ( n \right ) $.



\end{document}
